import java.util.ArrayList;
import java.sql.Date;
import java.math.*;

public class Node
{
  ArrayList<Packet> interests = new ArrayList<Packet>();       // interests to be sent along
  ArrayList<Packet> exploratoryData = new ArrayList<Packet>(); // exploratory data to be sent along
  ArrayList<Packet> reinforcements = new ArrayList<Packet>();  // reinforcements to be sent along
  ArrayList<Packet> reinforcedData = new ArrayList<Packet>();  // reinforced data to be sent along
  ArrayList<Data> generatedData = new ArrayList<Data>();   // to be sent as reinforced data or exploratory data
                                                          // this is a circular queue of limited size genLimit
                                                          // one item is generated at each time-step
                                                          // the last item in the list is always the newest
  int genLimit = 100;
  DataType genType; // the type of data being generated by this node.
  boolean generating; // whether this node is generating data.

  ArrayList<Node> allNodes;                            // every node in the entire network
  ArrayList<Node> myNeighbors = new ArrayList<Node>(); // neighbouring nodes

  public int nodeID;
  public int xCoord;
  public int yCoord;
  public int radioRange;
  public int numNodes;

  public Node(int nodeID, int xCoord, int yCoord, int radioRange, int numNodes)
  {
    this.nodeID = nodeID;
    this.xCoord = xCoord;
    this.yCoord = yCoord;
    this.radioRange = radioRange;
    this.numNodes = numNodes;
  }

  public void run(long currentTime) //This runs at each time-stamp
  {
    //send all interests in the queue.
    sendInterests(currentTime);
    //send all expData
    sendExploratoryData();
    //send all reinforments
    sendReinforcements();
    //send all reinforcedData
    sendReinforcedData();
    //send one generated data if enough time has passed. This amount of time might be 1 unit, maybe 0, maybe way more.
    sendGeneratedData();
  }

  public void startGeneration(DataType dType)
  {
    genType = dType;
    generating = true;
  }

  public void generateData()
  {
    if(generating)
    {
      if(generatedData.size() == genLimit)
      {
        generatedData.remove(0);
      }
      generatedData.add(new Data((int)(Math.random()*256), genType));
    }
  }

  public void startInterest(int interval, int quantity, DataType type)
  {
    //TODO
  }

  public void sendInterests(long currentTime)
  {
    //TODO
  }

  public void sendExploratoryData()
  {
    //TODO
  }

  public void sendReinforcements()
  {
    //TODO
  }

  public void sendReinforcedData()
  {
    //TODO
  }

  public void sendGeneratedData()
  {
    //TODO
    //only send one at a time
    //once all are sent, turn off generating
  }

  public boolean isThereStillWorkToBeDone()
  {
    return interests.size()   != 0
    || exploratoryData.size() != 0
    || reinforcements.size()  != 0
    || reinforcedData.size()  != 0
    || generatedData.size()   != 0;
  }

  public void setAllNodes(ArrayList<Node> allNodes)
  {
    this.allNodes = allNodes;
  }

  public void findNeighbors()
  {
    for(int i=0; i<numNodes; i++)
    {
      if(this.xCoord != allNodes.get(i).xCoord || this.yCoord != allNodes.get(i).yCoord)
      {
        int xDiff = Math.abs(allNodes.get(i).xCoord - this.xCoord);
        int yDiff = Math.abs(allNodes.get(i).yCoord - this.yCoord);

        if(xDiff <= radioRange && yDiff <= radioRange)
        {
          myNeighbors.add(allNodes.get(i));
        }
      }
    }
  }
}
