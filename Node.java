import java.util.ArrayList;
import java.sql.Date;
import java.math.*;

public class Node
{
  ArrayList<InterestPacket> interests = new ArrayList<InterestPacket>();       // interests to be sent along
  ArrayList<ExploratoryDataPacket> exploratoryData = new ArrayList<ExploratoryDataPacket>(); // exploratory data to be sent along
  ArrayList<ReinforcementPacket> reinforcements = new ArrayList<ReinforcementPacket>();  // reinforcements to be sent along
  ArrayList<ReinforcedDataPacket> reinforcedData = new ArrayList<ReinforcedDataPacket>();  // reinforced data to be sent along

  ArrayList<InterestPacket> interestsSentAsTheSink = new ArrayList<InterestPacket>();  // interests which initiated with this node, which is a sink
  ArrayList<InterestPacket> interestsToRespondToAsTheSource = new ArrayList<InterestPacket>();  // reinforced data to be sent from this Node, which is the source.

  boolean generating; // whether this node is generating data. Set at the beginning of the simulation by NodeTest
  DataType genType;   // the type of data being generated by this node. Set at the beginning of the simulation by NodeTest
  Data genData;       // the data which was generated at the current point in time.

  boolean doneSendingRequestedGeneratedData = true;
  int genAmount = 0;  // the number of requested pieces of data
  int genPeriod = 1;  // the period of requested pieces of data (1 means at every run(); 2 at every second; etc.).
  int genPeriodCounter = 0;
  long requestID = 0;

  ArrayList<Node> allNodes;                            // every node in the entire network
  ArrayList<Node> myNeighbors = new ArrayList<Node>(); // neighbouring nodes

  public int nodeEnergyUsed = 0; //the total energy used by the node.

  public int nodeID;     // the ID of this node (starting at 0)
  public int xCoord;     // where this node is.
  public int yCoord;     // where this node is.
  public int radioRange;
  public int numNodes;   // the number of nodes in the entire network.

  // HDA THINGS
  public ArrayList<NodeLevelObject> nodeLevels = new ArrayList<NodeLevelObject>(); //THIS IS CURRENTLY NOT USED FOR THE SIMPLIFIED HDA.

  public Node(int nodeID, int xCoord, int yCoord, int radioRange, int numNodes)
  {
    this.nodeID = nodeID;
    this.xCoord = xCoord;
    this.yCoord = yCoord;
    this.radioRange = radioRange;
    this.numNodes = numNodes;
  }

  public void run(long currentTime) //This runs at each time-stamp
  {
    //System.out.println("- - running Node: " + nodeID);
    generateData();

    //send all interests in the queue.
    sendInterests();                    //broadcast

    //send all expData
    sendExploratoryDataPacketThrough(); //broadcast

    //send all reinforments
    sendReinforcements();               //monocast

    //send all reinforcedData
    sendReinforcedDataPacketThrough();  //monocast

    //send one generated data if enough time has passed as exploratory data.
    sendExploratoryDataAsSource();      //broadcast

    //reinforce a path
    sendReinforcedDataAsSource();       //monocast
  }

  public void startGeneration(DataType dType)
  {
    genType = dType;
    generating = true;
  }

  public void generateData()
  {
    if(generating)
    {
      //generate random data
      genData = new Data((int)(Math.random()*256), genType);
    }
  }

  public void startInterest(int period, int amount, DataType type, long currentTime)
  {
    //Seed an interest in the network.
    InterestPacket pkt = new InterestPacket(this, currentTime, false, type, null, amount, period, 0);
    interestsSentAsTheSink.add(pkt);

    // Make sure we don't re-send this packet when it comes back to us.
    InterestPacket tmp = pkt.clone();
    tmp.ifsent = true;
    interests.add(tmp);

    setOurLevel(currentTime, 0);

    System.out.println("oE");
    broadcast(pkt);
  }

  public void receivePacket(Packet pkt)
  {
    if(pkt instanceof InterestPacket)
    {
      InterestPacket tmp = ((InterestPacket)pkt).clone();
      tmp.level++;

      //See if interest is for this node
      //  if it is, see if we have one with this id in our interestsToRespondToAsTheSource, and if there is not one there, add it.
      if(generating && genType == pkt.dType)
      {
        //It's for me; I am the source for this packet.
        boolean haveintrespalready = false;
        for(InterestPacket intpp : interestsToRespondToAsTheSource)
        {
          if(intpp.id == pkt.id)
          {
            haveintrespalready = true;
            break;
          }
        }
        if(!haveintrespalready)
          interestsToRespondToAsTheSource.add(tmp.clone());
      }

      //get our current level for this id
      int curLevel = getOurLevel(pkt.id);
      //  if it's -1, add this packet to our interests and set our level.
      if(curLevel == -1)
      {
        interests.add(tmp);
        setOurLevel(tmp.id, tmp.level);
      }
      //  if it's greater than the level for this packet, add this packet to our interests.
      else if(curLevel > ((InterestPacket)pkt).level)
      {
        tmp.ifsent = true;
        interests.add(tmp);
      }
      //  if it's lower or equal to the id for this packet, abandon it.
      else
      {
        //do nothing.
      }
    }
    else if(pkt instanceof ExploratoryDataPacket)
    {
      //See if we already have exploratory data for this id.
      boolean foundAlready = false;
      for(ExploratoryDataPacket parket : exploratoryData)
      {
        if(parket.id == pkt.id)
        {
          //We already have this ID. Ignore this packet.
          foundAlready = true;
          break;
        }
      }
      if(foundAlready)
        return;

      //only ever send the first time we see this ID
      //see if this node originated the interest
      for(InterestPacket p : interestsSentAsTheSink)
      {
        //see if this node started this id
        if(p.id == pkt.id)
        {
          //This node started this id. Send reinforcement.
          reinforcements.add(new ReinforcementPacket(this, pkt.id, false, pkt.dType, null, pkt.requestedAmount, pkt.requestedPeriod));
          pkt.ifsent = true; // so that we don't resend a packet which is for us.
          break;
        }
      }
      exploratoryData.add((ExploratoryDataPacket)pkt); //if it's for us or not, but only send the first one we see.
    }
    else if(pkt instanceof ReinforcementPacket)
    {
      //See if we already have exploratory data for this id.
      boolean alreadyHave = false;
      for(ReinforcementPacket parket : reinforcements)
      {
        if(parket.id == pkt.id)
        {
          //We already have this ID. Ignore this packet.
          alreadyHave = true;
          break;
        }
      }
      if(alreadyHave)
        return;

      if(generating && genType == pkt.dType)
      {
        //It's for me; I am the source for this packet.
        //enable the sending of generated data as reinforced data, and sets its parameters.
        doneSendingRequestedGeneratedData = false;
        genAmount = pkt.requestedAmount;
        genPeriod = pkt.requestedPeriod;
        requestID = pkt.id;
        genPeriodCounter = 0;
        pkt.ifsent = true; //don't send along a packet which was for us. ONLY ONE SOURCE PER DATA TYPE.
      }
      reinforcements.add((ReinforcementPacket)pkt); //add it to the list (to be sent if not for us)
    }
    else if(pkt instanceof ReinforcedDataPacket)
    {
      boolean foundIt = false;
      // See if the packet is for me
      for(InterestPacket p : interestsSentAsTheSink)
      {
        if(p.id == pkt.id)
        {
          // It is for us! We are the sink for this packet.
          System.out.println("  - - -o  Sink Node: " + nodeID + " received data: \t" + pkt.datum.datum + "\t id: " + pkt.id);
          foundIt = true;
          break;
        }
      }
      if(!foundIt)
      {
        reinforcedData.add((ReinforcedDataPacket)pkt); //if it wasn't for us, send it along.
      }
    }
    else
    {
      System.out.println("===ERROR===     No Packet Type.");
    }
  }

  public void sendInterests()
  {
    // send all of the unsent interests.
    for(InterestPacket pkt : interests)
    {
      if(pkt.ifsent == false)
      {
        System.out.println("-E");
        //Send out the broadcast
        broadcast(pkt);
        pkt.ifsent = true;
      }
    }
  }

  public void sendExploratoryDataPacketThrough()
  {
    ArrayList<Node> nods;
    for(ExploratoryDataPacket pkt : exploratoryData)
    {
      if(pkt.ifsent == false)
      {
        System.out.println("- -{");
        //Figure out who to multicast to
        nods = new ArrayList<Node>();
        for(InterestPacket intP : interests)
        {
          if(intP.id == pkt.id)
          {
            nods.add(intP.sender);
          }
        }

        //Send out the multicast
        multicast(pkt, nods);
        pkt.ifsent = true;
      }
    }
  }

  public void sendReinforcements()
  {
    Node sendTo = null;
    // send all of the unsent reinforcements packets.
    //System.out.println("SIZE: "+ reinforcements.size());
    int siz = reinforcements.size();
    for(int i = 0; i < siz; i++)
    {
      //System.out.println(i + " " + reinforcements.get(i).ifsent + " " + reinforcements.get(i).id);
      if(reinforcements.get(i).ifsent == false)
      {
        //send to the node from the packet with this id from the exploratoryData list.
        //there will only be one, and it will have been the fastest.
        for(ExploratoryDataPacket expkt : exploratoryData)
        {
          if(expkt.id == reinforcements.get(i).id)
          {
            sendTo = expkt.sender;
            //System.out.println("We found which to send reinf to: " + i);
          }
        }

        if(sendTo == null)
        {
          System.out.println("could not find who to send reinf to.");
          return;
        }
        if(reinforcements.get(i).sender == this)
        {
          System.out.println("o - -+");
        }else{
          System.out.println("- - -+");
        }
        if(!myNeighbors.contains(sendTo))
          System.out.println("ERROR 404: Sending to non-neighbours");
        monocast(reinforcements.get(i), sendTo);
        reinforcements.get(i).ifsent = true;
      }
    }
  }

  public void sendReinforcedDataPacketThrough()
  {
    Node sendTo = null;
    // send all of the unsent reinforcedData packets.
    for(ReinforcedDataPacket pkt : reinforcedData)
    {
      if(pkt.ifsent == false)
      {
        //send to the node from the packet with this id from the reinforcements list.
        //there will only be one.
        for(ReinforcementPacket reinfpkt : reinforcements)
        {
          if(reinfpkt.id == pkt.id)
          {
            sendTo = reinfpkt.sender;
            //System.out.println("We found which to send reinfdata to.");
          }
        }

        if(sendTo == null)
        {
          System.out.println("could not find who to send reinfdata to.");
          return;
        }
        System.out.println("- - - -+");
        if(!myNeighbors.contains(sendTo))
          System.out.println("ERROR 403: Sending to non-neighbours");
        monocast(pkt, sendTo);
        pkt.ifsent = true;
      }
    }
  }

  public void sendExploratoryDataAsSource()
  {
    ArrayList<Node> nods;
    for(InterestPacket pkt : interestsToRespondToAsTheSource)
    {
      if(pkt.ifsent == false)
      {
        nods = new ArrayList<Node>();
        for(InterestPacket intP : interests)
        {
          if(intP.id == pkt.id)
          {
            nods.add(intP.sender);
          }
        }
        //genPeriodCounter = 0;
        System.out.println("o -E");
        multicast(new ExploratoryDataPacket(this, requestID, false, genType, genData, pkt.requestedAmount, pkt.requestedPeriod), nods);
        pkt.ifsent = true;
      }
    }
  }

  public void sendReinforcedDataAsSource()
  {
    ReinforcementPacket pkt = null;
    //This function will send data of type genType every genPeriod runs for a total of genAmount times.

    //check to see that we have received a request
    if(doneSendingRequestedGeneratedData)
      return;

    if(genAmount <= 0)
    {
      doneSendingRequestedGeneratedData = true;
      return;
    }

    genPeriodCounter++;

    if(genPeriodCounter % genPeriod != 0) // send a reinforced data packet every genPeriod time-stamps.
      return;

    genAmount--;

    Node sendTo = null;
    //send to the node from the packet with this id from the reinforcements list.
    //there will only be one.
    for(ReinforcementPacket reinfpkt : reinforcements)
    {
      if(reinfpkt.id == requestID)
      {
        sendTo = reinfpkt.sender;
        pkt = reinfpkt;
        break;
        //System.out.println("We found which to send reinfdata to [from source].");
      }
    }

    if(sendTo == null)
    {
      System.out.println("===ERROR===    could not find who to send reinfdata to [from source].");
      return;
    }
    System.out.println("o - - -+");
    if(!myNeighbors.contains(sendTo))
      System.out.println("ERROR 402: Sending to non-neighbours");
    monocast(new ReinforcedDataPacket(this, requestID, false, genType, genData, pkt.requestedAmount, pkt.requestedPeriod), sendTo);
  }

  public void broadcast(Packet pkt)
  {
    //    if(nodeID == 0) //Single out a specific node for testing
    //      System.out.println("==== Node " + nodeID + " sent Packet. id: " + pkt.id + ", sender: " + pkt.sender.nodeID + ", pType: " + pkt.pType);
    Packet tmp;
    nodeEnergyUsed++;
    for(Node nod : myNeighbors)
    {
      tmp = pkt.clone();
      tmp.sender = this;
      nod.receivePacket(tmp);
    }
  }

  public void monocast(Packet pkt, Node nod)
  {
    //    if(nodeID == 0) //Single out a specific node for testing
    //      System.out.println("==== Node " + nodeID + " sent Packet. id: " + pkt.id + ", sender: " + pkt.sender.nodeID + ", pType: " + pkt.pType);
    Packet tmp;
    nodeEnergyUsed++;
    if(!myNeighbors.contains(nod))
      System.out.println("===ERROR===               monocast sent to node: " + nod.nodeID + ", which is NOT A NEIGHBOUR");
    tmp = pkt.clone();
    tmp.sender = this;
    nod.receivePacket(tmp);
  }

  public void multicast(Packet pkt, ArrayList<Node> nods)
  {
    Packet tmp;
    nodeEnergyUsed++;
    for(Node nod : nods)
    {
      if(!myNeighbors.contains(nod))
        System.out.println("===ERROR===               monocast sent to node: " + nod.nodeID + ", which is NOT A NEIGHBOUR");
      tmp = pkt.clone();
      tmp.sender = this;
      nod.receivePacket(tmp);
      //System.out.println("multicasting to: " + nod.nodeID);
    }
  }

  public boolean isThereStillWorkToBeDone()
  {
    if(!doneSendingRequestedGeneratedData)
      return true;
    for(Packet pkt : interests)
    {
      if(!pkt.ifsent)
        return true;
    }
    for(Packet pkt : exploratoryData)
    {
      if(!pkt.ifsent)
        return true;
    }
    for(Packet pkt : reinforcements)
    {
      if(!pkt.ifsent)
        return true;
    }
    for(Packet pkt : reinforcedData)
    {
      if(!pkt.ifsent)
        return true;
    }
    return false;
  }

  public void setAllNodes(ArrayList<Node> allNodes)
  {
    this.allNodes = allNodes;
  }

  public void findNeighbors()
  {
    for(int i=0; i<numNodes; i++)
    {
      // If we are not the node which is currently being considered.
      if(this.xCoord != allNodes.get(i).xCoord || this.yCoord != allNodes.get(i).yCoord)
      {
        int xDiff = Math.abs(allNodes.get(i).xCoord - this.xCoord);
        int yDiff = Math.abs(allNodes.get(i).yCoord - this.yCoord);

        if(xDiff <= radioRange && yDiff <= radioRange)
        {
          //          System.out.println("Node " + nodeID + " is adding node " + allNodes.get(i).nodeID + " to its neighbours. It is as far away as x = " + xDiff + " and y = " + yDiff);
          myNeighbors.add(allNodes.get(i));
        }
      }
    }
  }

  public void setOurLevel(long id, int level)
  {
    boolean found = false;

    for(NodeLevelObject n : nodeLevels)
    {
      if(n.id == id)
      {
        found = true;
        break;
      }
    }

    if(!found)
    {
      nodeLevels.add(new NodeLevelObject(id, level));
    }
  }

  public int getOurLevel(long id)
  {
    int result = -1;

    for(NodeLevelObject n : nodeLevels)
    {
      if(n.id == id)
        return n.level;
    }

    return result; //result = -1, which means our level for this id has not yet been set.
  }

  class NodeLevelObject
  {
    long id;
    int level;

    public NodeLevelObject(long id, int level)
    {
      this.id = id;
      this.level= level;
    }
  }
}
