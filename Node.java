import java.util.ArrayList;
import java.sql.Date;
import java.math.*;

public class Node
{
  ArrayList<Packet> interests = new ArrayList<Packet>();       // interests to be sent along
  ArrayList<Packet> exploratoryData = new ArrayList<Packet>(); // exploratory data to be sent along
  ArrayList<Packet> reinforcements = new ArrayList<Packet>();  // reinforcements to be sent along
  ArrayList<Packet> reinforcedData = new ArrayList<Packet>();  // reinforced data to be sent along

  ArrayList<Packet> interestsToRespondToAsSource = new ArrayList<Packet>();  // reinforced data to be sent from this Node, which is the source.
  boolean generating; // whether this node is generating data. Set at the beginning of the simulation by NodeTest
  DataType genType;   // the type of data being generated by this node. Set at the beginning of the simulation by NodeTest
  Data genData;       // the data which was generated at the current point in time.

  boolean doneSendingRequestedGeneratedData = true;
  int genAmount = 0;  // the number of requested pieces of data
  int genPeriod = 1;  // the period of requested pieces of data (1 means at every run(); 2 at every second; etc.).
  int genPeriodCounter = 0;
  long requestID = 0;

  ArrayList<Node> allNodes;                            // every node in the entire network
  ArrayList<Node> myNeighbors = new ArrayList<Node>(); // neighbouring nodes

  public int nodeID;
  public int xCoord;
  public int yCoord;
  public int radioRange;
  public int numNodes;

  public Node(int nodeID, int xCoord, int yCoord, int radioRange, int numNodes)
  {
    this.nodeID = nodeID;
    this.xCoord = xCoord;
    this.yCoord = yCoord;
    this.radioRange = radioRange;
    this.numNodes = numNodes;
  }

  public void run(long currentTime) //This runs at each time-stamp
  {
    generateData();
    //send all interests in the queue.
    sendInterests();
    //send all expData
    sendExploratoryDataPacketThrough();
    //send all reinforments
    sendReinforcements();
    //send all reinforcedData
    sendReinforcedDataPacketThrough();
    //send one generated data if enough time has passed. This amount of time might be 1 unit, maybe 0, maybe way more.
    sendExploratoryDataAsSource();
    sendReinforcedDataAsSource();
  }

  public void startGeneration(DataType dType)
  {
    genType = dType;
    generating = true;
  }

  public void generateData()
  {
    if(generating)
    {
      genData = new Data((int)(Math.random()*256), genType);
    }
  }

  public void startInterest(int interval, int quantity, DataType type, long currentTime)
  {
    broadcast(new Packet(this, PacketType.INTEREST, currentTime, false, type));
  }

  public void receivePacket(Packet pkt)
  {
    //TODO
    //1. figure out what kind of packet it is
    //2. figure out if we have one of its kind already
    //3. store it as necessary; Do magic if we are the source or the sink
    //
    //doneSendingRequestedGeneratedData = false if we get an interest request.
    //if we are to be the source, CLONE interests to interestsToRespondToAsSource and enable things
  }

  public void sendInterests()
  {
    // send all of the unsent interests.
    for(Packet pkt : interests)
    {
      if(pkt.ifsent == false)
      {
        broadcast(pkt);
        pkt.ifsent = true;
      }
    }
  }

  public void sendExploratoryDataPacketThrough()
  {
    // send all of the unsent expData packets.
    for(Packet pkt : exploratoryData)
    {
      if(pkt.ifsent == false)
      {
        broadcast(pkt);
        pkt.ifsent = true;
      }
    }
  }

  public void sendReinforcements()
  {
    Node sendTo = null;
    // send all of the unsent reinforcements packets.
    for(Packet pkt : reinforcements)
    {
      if(pkt.ifsent == false)
      {
        //send to the node from the packet with this id from the exploratoryData list.
        for(Packet expkt : exploratoryData)
        {
          if(expkt.id == pkt.id)
          {
            sendTo = expkt.sender;
            System.out.println("We found which to send reinf to.");
          }
        }

        if(sendTo == null)
        {
          System.out.println("could not find who to send reinf to.");
          return;
        }
        monocast(pkt, sendTo);
        pkt.ifsent = true;
      }
    }
  }

  public void sendReinforcedDataPacketThrough()
  {
    Node sendTo = null;
    // send all of the unsent reinforcedData packets.
    for(Packet pkt : reinforcedData)
    {
      if(pkt.ifsent == false)
      {
        //send to the node from the packet with this id from the reinforcements list.
        for(Packet reinfpkt : reinforcements)
        {
          if(reinfpkt.id == pkt.id)
          {
            sendTo = reinfpkt.sender;
            System.out.println("We found which to send reinfdata to.");
          }
        }

        if(sendTo == null)
        {
          System.out.println("could not find who to send reinfdata to.");
          return;
        }
        monocast(pkt, sendTo);
        pkt.ifsent = true;
      }
    }
  }

  public void sendExploratoryDataAsSource()
  {
    if(doneSendingRequestedGeneratedData)
      return;

    for(Packet pkt : interestsToRespondToAsSource)
    {
      if(pkt.ifsent == false)
      {
        broadcast(new Packet(this, PacketType.EXPLORATORYDATA, requestID, false, genType, genData));
        pkt.ifsent = true;
        genPeriodCounter = 0;
      }
    }

  }

  public void sendReinforcedDataAsSource()
  {
    //This function will send data of type genType every genPeriod runs for a total of genAmount times.
    //check to see that we have received a request
    if(doneSendingRequestedGeneratedData)
      return;

    if(genAmount <= 0)
    {
      doneSendingRequestedGeneratedData = true;
      return;
    }

    genPeriodCounter++;

    if(genPeriodCounter % genPeriod != 0)
      return;

    genAmount--;

    Node sendTo = null;
    //send to the node from the packet with this id from the reinforcements list.
    for(Packet reinfpkt : reinforcements)
    {
      if(reinfpkt.id == requestID)
      {
        sendTo = reinfpkt.sender;
        System.out.println("We found which to send reinfdata to [from source].");
      }
    }

    if(sendTo == null)
    {
      System.out.println("could not find who to send reinfdata to [from source].");
      return;
    }
    monocast(new Packet(this, PacketType.REINFORCEDDATA, requestID, false, genType, genData), sendTo);
  }

  public void broadcast(Packet pkt)
  {
    for(Node nod : myNeighbors)
    {
      nod.receivePacket(pkt.clone());
    }
  }

  public void monocast(Packet pkt, Node nod)
  {
    nod.receivePacket(pkt.clone());
  }

  public boolean isThereStillWorkToBeDone()
  {
    return interests.size()   != 0
    || exploratoryData.size() != 0
    || reinforcements.size()  != 0
    || reinforcedData.size()  != 0
    || !doneSendingRequestedGeneratedData;
  }

  public void setAllNodes(ArrayList<Node> allNodes)
  {
    this.allNodes = allNodes;
  }

  public void findNeighbors()
  {
    for(int i=0; i<numNodes; i++)
    {
      if(this.xCoord != allNodes.get(i).xCoord || this.yCoord != allNodes.get(i).yCoord)
      {
        int xDiff = Math.abs(allNodes.get(i).xCoord - this.xCoord);
        int yDiff = Math.abs(allNodes.get(i).yCoord - this.yCoord);

        if(xDiff <= radioRange && yDiff <= radioRange)
        {
          myNeighbors.add(allNodes.get(i));
        }
      }
    }
  }
}
